//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by diegen. DO NOT EDIT.

package resources

import (
	v1 "dies.dev/apis/meta/v1"
	json "encoding/json"
	fmtx "fmt"
	unstructured "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

var TestObjBlank = (&TestObjDie{}).DieFeed(TestObj{})

type TestObjDie struct {
	v1.FrozenObjectMeta
	mutable bool
	r       TestObj
}

// DieImmutable returns a new die for the current die's state that is either mutable (`false`) or immutable (`true`).
func (d *TestObjDie) DieImmutable(immutable bool) *TestObjDie {
	if d.mutable == !immutable {
		return d
	}
	d = d.DeepCopy()
	d.mutable = !immutable
	return d
}

// DieFeed returns a new die with the provided resource.
func (d *TestObjDie) DieFeed(r TestObj) *TestObjDie {
	if d.mutable {
		d.FrozenObjectMeta = v1.FreezeObjectMeta(r.ObjectMeta)
		d.r = r
		return d
	}
	return &TestObjDie{
		FrozenObjectMeta: v1.FreezeObjectMeta(r.ObjectMeta),
		mutable:          d.mutable,
		r:                r,
	}
}

// DieFeedPtr returns a new die with the provided resource pointer. If the resource is nil, the empty value is used instead.
func (d *TestObjDie) DieFeedPtr(r *TestObj) *TestObjDie {
	if r == nil {
		r = &TestObj{}
	}
	return d.DieFeed(*r)
}

// DieRelease returns the resource managed by the die.
func (d *TestObjDie) DieRelease() TestObj {
	if d.mutable {
		return d.r
	}
	return *d.r.DeepCopy()
}

// DieReleasePtr returns a pointer to the resource managed by the die.
func (d *TestObjDie) DieReleasePtr() *TestObj {
	r := d.DieRelease()
	return &r
}

// DieReleaseUnstructured returns the resource managed by the die as an unstructured object.
func (d *TestObjDie) DieReleaseUnstructured() runtime.Unstructured {
	r := d.DieReleasePtr()
	u, _ := runtime.DefaultUnstructuredConverter.ToUnstructured(r)
	return &unstructured.Unstructured{
		Object: u,
	}
}

// DieStamp returns a new die with the resource passed to the callback function. The resource is mutable.
func (d *TestObjDie) DieStamp(fn func(r *TestObj)) *TestObjDie {
	r := d.DieRelease()
	fn(&r)
	return d.DieFeed(r)
}

// DeepCopy returns a new die with equivalent state. Useful for snapshotting a mutable die.
func (d *TestObjDie) DeepCopy() *TestObjDie {
	r := *d.r.DeepCopy()
	return &TestObjDie{
		FrozenObjectMeta: v1.FreezeObjectMeta(r.ObjectMeta),
		mutable:          d.mutable,
		r:                r,
	}
}

var _ runtime.Object = (*TestObjDie)(nil)

func (d *TestObjDie) DeepCopyObject() runtime.Object {
	return d.r.DeepCopy()
}

func (d *TestObjDie) GetObjectKind() schema.ObjectKind {
	r := d.DieRelease()
	return r.GetObjectKind()
}

func (d *TestObjDie) MarshalJSON() ([]byte, error) {
	return json.Marshal(d.r)
}

func (d *TestObjDie) UnmarshalJSON(b []byte) error {
	if d == TestObjBlank {
		return fmtx.Errorf("cannot unmarshal into the blank die, create a copy first")
	}
	if !d.mutable {
		return fmtx.Errorf("cannot unmarshal into immutable dies, create a mutable version first")
	}
	r := &TestObj{}
	err := json.Unmarshal(b, r)
	*d = *d.DieFeed(*r)
	return err
}

// MetadataDie stamps the resource's ObjectMeta field with a mutable die.
func (d *TestObjDie) MetadataDie(fn func(d *v1.ObjectMetaDie)) *TestObjDie {
	return d.DieStamp(func(r *TestObj) {
		d := v1.ObjectMetaBlank.DieImmutable(false).DieFeed(r.ObjectMeta)
		fn(d)
		r.ObjectMeta = d.DieRelease()
	})
}

func (d *TestObjDie) Spec(v TestSpec) *TestObjDie {
	return d.DieStamp(func(r *TestObj) {
		r.Spec = v
	})
}

func (d *TestObjDie) Status(v TestStatus) *TestObjDie {
	return d.DieStamp(func(r *TestObj) {
		r.Status = v
	})
}
